package Calcs;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.util.Arrays;
import java.util.Base64;

/**
 * @author Zwickelstorfer Felix
 * to En- and decrypte sensitive data like passwords, with hellman key-exchange and AES encryption
 */
public class Crypto {

    /**
     * A large prime number for the hellman key-exchange
     */
    private final BigInteger p;

    /**
     * A generator which is related to {@link Crypto#p} because it always has to be smaller.
     * Its generated by the server.
     */
    private final BigInteger g;

    /**
     * the private Value, which was calculated
     */
    private int myPriv;

    /**
     * the public value from the other connection
     */
    private BigInteger myPub;

    /**
     * the key which was created by the hellman key-exchange
     */
    public SecretKey key = null;

    /**
     * its used for the en- and decryption
     */
    private final IvParameterSpec iv;

    /**
     * creates a new Object for the Server, that means it initializes all values
     */
    public Crypto() {
        int min = 10000;
        p = new BigInteger("998957");
        g = new BigInteger("" + ((long) (Math.random() * (p.intValue() - min) + min)));
        createPrivVal();
        iv = generateIv();
    }

    /**
     * creates the new Object for a Client, so it doesn't have to initialize all values, but only the private Val
     * @param p {@link Crypto#p}
     * @param g {@link Crypto#g}
     * @param ivStr {@link Crypto#iv} as a byte-Array formatted String
     */
    public Crypto(BigInteger p, BigInteger g, String ivStr) {
        this.p = p;
        this.g = g;
        ivStr = ivStr.replaceAll("[^0-9,-]", "");
        String[] str = ivStr.split(",");
        byte[] iv = new byte[str.length];
        for (int i = 0; i < str.length; i++) iv[i] = Byte.parseByte(str[i]);
        this.iv = new IvParameterSpec(iv);
        createPrivVal();
    }

    public BigInteger getPub() {
        return myPub;
    }

    /**
     * creates the private Value for the hellman key-exchange
     */
    private void createPrivVal() {
        BigInteger min = new BigInteger("1000");
        SecureRandom src = new SecureRandom();
        myPriv = (int) (src.nextDouble() * (p.subtract(min).intValue()) + min.intValue());
        myPub = g.pow(myPriv).mod(p);
    }

    /**
     * creates the secret key
     * @param oPub the public key of the other Crypto-object
     * @param serverPub the public key of the server
     */
    public void createKey(BigInteger oPub, int serverPub) {
        int key = new BigInteger("" + (oPub.pow(myPriv)).mod(p)).intValue();
        try {
            this.key = getKeyFromPassword("" + key, "" + serverPub);
        } catch (NoSuchAlgorithmException | InvalidKeySpecException ignored) {
        }
    }

    /**
     * encrypts the String
     */
    public String encrypt(String s) {
        try {
            return encrypt(s, key, iv);
        } catch (Exception ignored) {
            return "";
        }
    }

    /**
     * decrypts the String
     */
    public String decrypt(String s) {
        try {
            return decrypt(s, key, iv);
        } catch (Exception ignored) {
            return "";
        }
    }

    /**
     * creates a secret Key with the password and salt
     */
    private static SecretKey getKeyFromPassword(String password, String salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt.getBytes(), 65536, 256);
        return new SecretKeySpec(factory.generateSecret(spec).getEncoded(), "AES");
    }

    /**
     * generates the IvParameterSpec
     */
    private static IvParameterSpec generateIv() {
        byte[] iv = new byte[16];
        new SecureRandom().nextBytes(iv);
        return new IvParameterSpec(iv);
    }

    /**
     * encrypts the String
     * @param input the String which will be encrypted
     * @param key the key with whoom it will be encrypted
     * @param iv {@link Crypto#iv}
     * @return the encrypted String
     */
    private static String encrypt(String input, SecretKey key, IvParameterSpec iv) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);
        byte[] cipherText = cipher.doFinal(input.getBytes());
        return Base64.getEncoder().encodeToString(cipherText);
    }


    /**
     * decrypt the String
     * @param cipherText the String which will be decrypted
     * @param key the key with whoom it will be decrypted
     * @param iv {@link Crypto#iv}
     * @return the decrypted String
     */
    private static String decrypt(String cipherText, SecretKey key, IvParameterSpec iv) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, key, iv);
        byte[] plainText = cipher.doFinal(Base64.getDecoder().decode(cipherText));
        return new String(plainText);
    }

    @Override
    public String toString() {
        return "{" +
                "p=" + p +
                ", g=" + g +
                ", serPub=" + myPub +
                ", iv=" + Arrays.toString(iv.getIV()) +
                '}';
    }

  /*  s public static void main(String[] args) throws Exception {
        Crypto pA = new Crypto();
        Crypto pB = new Crypto(pA.p, pA.g, Arrays.toStr(pA.iv.getIV()));

        pA.createKey(pB.myPub, pA.myPub.intValue());
        pB.createKey(pA.myPub, pA.myPub.intValue());

        String test = "Hallo Welt";
        SecretKey secureKeyA = getKeyFromPassword("" + pA.key, "" + pA.myPub.intValue());
        SecretKey secureKeyB = getKeyFromPassword("" + pB.key, "" + pA.myPub.intValue());
        IvParameterSpec iv = generateIv();
        String enc;
        System.out.println(enc = encrypt(test, secureKeyA, iv));
        System.out.println(decrypt(enc, secureKeyB, iv));
    }
*/

}
